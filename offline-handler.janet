# offline-handler.janet
# Implements the logic to try and find a command from offline templates.

(import string)

# Load the templates.
# Using dofile for simplicity here, assuming offline-templates.janet is in the same directory
# or accessible via Janet's module resolution paths.
# If this were a larger project, a more structured import system might be used.
(dofile "offline-templates.janet") # This executes offline-templates.janet and makes its defs available.
                                   # `offline-command-templates` is now defined in this environment.

(defn try-offline-fallback [user-query target-os target-shell]
  "Attempts to find a matching command template from 'offline-command-templates'
  based on the user's query.

  Args:
    user-query: The natural language query from the user (string).
    target-os: The target operating system (string). (Currently unused, for future placeholder replacement)
    target-shell: The target shell (string). (Currently unused, for future placeholder replacement)

  Returns:
    A tuple [command-template, explanation-template] if a match is found.
    Returns nil if no matching template is found.
  "
  (unless (string? user-query) (return nil)) # Basic input validation

  (def lower-user-query (string/ascii-lower user-query))

  (loop [template :in offline-command-templates] # Iterate through each template table
    (loop [keyword :in (:keywords template)] # Iterate through keywords in the current template
      (if (string/find lower-user-query (string/ascii-lower keyword))
        # Match found!
        # For future: Implement placeholder substitution here if templates use {{OS}} or {{SHELL}}.
        # Example (conceptual):
        # (def cmd (string/replace-all "{{OS}}" target-os (:command-template template)))
        # (def expl (string/replace-all "{{OS}}" target-os (:explanation-template template)))
        # (return [cmd expl])
        (return [(:command-template template) (:explanation-template template)]))))

  # If no match is found after checking all templates and their keywords
  nil)

# --- Integration Comment for main.janet ---
# In main.janet, the flow would look something like this:
#
# (import ./offline-handler :as offline) # Or appropriate path
# (import ./ui)
# (import ./llm-api)
# (import ./utils)
# (import ./filter)
#
# (defn main [& args]
#   (def user-query (ui/get-user-query))
#   (if (empty? user-query)
#     (print "No query provided. Exiting.")
#     (return))
#
#   (def current-os (utils/get-current-os))
#   (def env-prefs (ui/get-target-environment current-os))
#
#   (def command nil)
#   (def explanation nil)
#   (def from-offline false)
#
#   # 1. Try offline fallback first
#   (let [offline-result (offline/try-offline-fallback user-query (:target-os env-prefs) (:target-shell env-prefs))]
#     (if offline-result
#       (do
#         (set command (offline-result 0))
#         (set explanation (offline-result 1))
#         (set from-offline true)
#         (print "\n[INFO] Found a potential offline match."))
#       (do
#         # 2. If no offline match, proceed with API
#         (ui/notify-external-api-usage) # Notify before API call
#         (def api-key (llm-api/get-api-key))
#         (unless api-key
#           (print "Failed to get API key. Exiting.")
#           (return))
#
#         (print "Generating command via LLM API...")
#         (let [llm-result (llm-api/generate-command-and-explanation user-query api-key (:target-os env-prefs) (:target-shell env-prefs))]
#           (set command (llm-result 0))
#           (set explanation (llm-result 1))))))
#
#   # 3. Process and display the result (whether from offline or API)
#   (if command
#     (let [warnings (filter/check-command-safety command)]
#       (ui/display-command-and-explanation command explanation warnings)
#       (if from-offline
#           (print "(This command was sourced from offline templates)")
#           (print "(This command was generated by an LLM)")))
#     (do
#       (print "\nSorry, couldn't generate a command for your query.")
#       (when explanation (print "Reason: " explanation)) # If LLM provided an error message
#       ))
# )

# --- Example Usage (for testing try-offline-fallback directly) ---
# (comment
#   (print (try-offline-fallback "show me how to list all files here" "linux" "bash"))
#   # Expected: ["ls -la" "Lists all files and directories in the current location with detailed information, including hidden files."]
#
#   (print (try-offline-fallback "what is my current path?" "macos" "zsh"))
#   # Expected: ["pwd" "Prints the full path of the current working directory."]
#
#   (print (try-offline-fallback "how do i get my ip address on windows" "windows" "powershell"))
#   # Expected: ["# Use OS-specific commands like 'ip addr' or 'ifconfig' on Linux/macOS, or 'ipconfig' on Windows." "To find your IP address, you typically use commands like 'ip addr' (Linux), 'ifconfig' or 'ipconfig getifaddr en0' (macOS), or 'ipconfig' (Windows). This cannot be determined by a single universal offline command."]
#
#   (print (try-offline-fallback "search for text in a document" "linux" "bash"))
#   # Expected: nil (if no template for "search text" or "grep" is added)
#
#   (print (try-offline-fallback "how to make a new folder called test" "linux" "bash"))
#   # Expected: ["mkdir new_directory_name" "Creates a new directory. Replace 'new_directory_name' with your desired directory name."]
# )
